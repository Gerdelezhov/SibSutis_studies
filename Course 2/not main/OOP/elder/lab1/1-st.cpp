#include <stdlib.h>
#include <stdio.h>
void PRD(int **a, int n) { // с правого верхнего угла по диагонали
     printf("\n[right] ");
     int x=0,y=n-1,i,j,*b,num=0; // икс и игрек - текущие координаты в матрице(элемента которые выводим)
     b=(int*)malloc(sizeof(int)*n*n); // выделяем память под массив
     while (y>=0) { // пока мы не вышли за границу матрицы по игреку
           i=x; // запоминаем текущие координаты во временное "хранилище"
           j=y;
           while ((i>0)&(j>0)) { // находим самый верхний элемент на диагонали
                 i--;
                 j--;
           }
           while ((i<n)&(j<n)) { // пока не вышли за границу матрицы снизу или справа
                 b[num]=a[i][j]; // запоминаем элемент матрицы в массив
                 num++;
                 i++; // двигаемся на шаг вниз вправо
                 j++;
           }
           if (y>0) { // если мы еще внитри матрицы, нужно вывести побочную диагональ
               i=x; // теже координаты по иксу
               j=y-1; // но по игреку на 1 меньше
               while ((i>0)&(j>0)) { // повторяем теже действия что и раньше
                     i--;
                     j--;
               }
               while ((i<n)&(j<n)) {
                     b[num]=a[i][j];
                     num++;
                     i++;
                     j++;
               }         
           }  
           x++; // переходим к следующей диагонали
           y--;
     } 
     for (int i=0;i<n*n;i++) printf("%4d",b[i]); // выводим элементы получившегося массива
     free(b); // освобождаем память
     printf("\n");
}
void PLD(int **a, int n) { // вывод из левого верхнего угла. тут все по аналогии только зекально отражено относительно оси игрек
     printf("\n[left]  ");
     int x=0,y=0,i,j,*b,num=0;
     b=(int*)malloc(sizeof(int)*n*n);
     while (y<n) {
           i=x;
           j=y;
           while ((i>0)&(j<n-1)) {
                 i--;
                 j++;
           }
           while ((i<n)&(j>=0)) {
                 b[num]=a[i][j];
                 num++;
                 i++;
                 j--;
           }
           i=x+1;
           j=y;
           while ((i>0)&(j<n-1)) {
                 i--;
                 j++;
           }
           while ((i<n)&(j>=0)) {
                 b[num]=a[i][j];
                 num++;
                 i++;
                 j--;
           }         
           x++;
           y++;
     } 
     for (int i=0;i<n*n;i++) printf("%4d",b[i]);    
     free(b); 
     printf("\n");
}
void PSA(int **a, int n) { // из угла в центр
     printf("\n[angle] ");
     int x=0,y=-1,steps=n,col=1,d=0,*b,num=0; // бужем сначала идти вправо в первой строке. steps - количество шагов по строке/столбцу
     b=(int*)malloc(sizeof(int)*n*n); // выделение памяти
     int dx[4]={0,1,0,-1}; // массив смещений по иксу и игреку
     int dy[4]={1,0,-1,0};
     while (steps>0) { // пока нужно делать шаги
           for (int i=0;i<steps;i++) { // делаем необходимое количество шагов
               x+=dx[d%4]; // шагам в нужно направлении по матрице
               y+=dy[d%4];               
               b[num]=a[x][y]; // запоминаем элемент
               num++;
           }          
           col++; // количество процденных строк/столбцов
           if (col==2) { // если прошли полностью угол (2 стороны матрицы)
              col=0; //значит у нас уменьшилось количество элементов в строке/столбце на 1 (тву как приблизились к центру)
              steps--;
           }
           d++;   // поворачиваем (меняем направление шагов: было вправо- стало вниз и тд) 
     } 
     for (int i=0;i<n*n;i++) printf("%4d",b[i]); // выводим
     free(b); // чистим
     printf("\n");
}
void PSC(int **a, int n) { // из центра в угол
     printf("\n[center]");
     int x=n/2,y=n/2,steps=1,col=0,d=0,*b,num=0; // аналогичная ситуация только количество шагов не уменьшается а увеличивается
     b=(int*)malloc(sizeof(int)*n*n);
     if (n%2==0) x=y=x-1;
     int dx[4]={0,1,0,-1};
     int dy[4]={1,0,-1,0};
     printf("%4d",a[x][y]);
     while (steps<n) {
           for (int i=0;i<steps;i++) {
               if (i==n) break;
               x+=dx[d%4];
               y+=dy[d%4];               
               b[num]=a[x][y];
               num++;
           }          
           col++;
           if (steps==n-1) {
              if (col==3) {
                 col=0;
                 steps++;
              }
           } else  
           if (col==2) {
              col=0;
              steps++;
           }
           d++;           
     } 
     for (int i=0;i<n*n-1;i++) printf("%4d",b[i]);
     free(b);
     printf("\n");
}
int main() {
     int **a,i,j,n; // a - матрица для зранения данных
     scanf("%d",&n); // считываем размерность матрицы
     a=(int**)malloc(sizeof(int*)*n); // выделем память для строки адресов
     for (i=0;i<n;i++)
         a[i]=(int*)malloc(sizeof(int)*n); // каждому элементу строки адресов выделяем память под столбец данных. В итоге получается матрица
     for (i=0;i<n;i++) {
         for (j=0;j<n;j++) {
             a[i][j]=rand()%(n*n); // заполняем случайными числами матрицу
             printf("%4d",a[i][j]); // выводим ее
         }
         printf("\n");
     }
     PRD(a,n);  // вызываем функции для вывода элементов матрицы по правилам
     PLD(a,n);
     PSA(a,n);   
     PSC(a,n);  
     for (i=0;i<n;i++) free(a[i]); // очищаем память матрицы
     free(a);      // очищаем память остаточного массива
     system("pause");
}
