1. Что определяет класс? Чем обличается класс от объекта?
Класс определяет пользовательский тип: описание данных и операций над ними. Объект - это конкретный экземпляр класса со своим состоянием.

2. Можно ли объявлять массив объектов? А массив классов?
Да. Нет. Только в метапрограммировании. boost::tuple

3. Разрешается ли объявлять указатель на объект? А указатель на класс?
Да. Нет.

4. Допускается ли передавать объекты в качестве параметров, и какими способами? А возвращать как результат?
По ссылке, по указателю. Возвращать также. По значению передаётся копия объекта.

5. Как называется использование объекта одного класса в качестве поля другого класса?
Композиция.

6. Является ли структура классом? Чем класс отличается от структуры?
Да. По умолчанию в классе все поля private

7. Какие ключевые слова в С++ обозначают класс?
class, struct

8. Объясните принцип инкапсуляции.
Сокрытие деталей реализации.

9. Что такое композиция?
Использование объекта одного класса в качестве поля другого.

10. Для чего используются ключевые слова public и private?
Для определения области видимости.

11. Можно ли использовать ключевые слова public и private в структуре?
Да.

12. Существуют ли ограничения на использование public и private в классе? А в структуре?
Нет. Нет.

13. Обязательно ли делать поля класса приватными?
Нет.

14. Что такое метод? Как вызывается метод?
Метод - это функция, определённая в классе.
Если статический, то вызывается для класса, если обычный - то для объекта класса.

15. Может ли метод быть приватный?
Да.

16. Как определить метод непосредственно внутри класса? А вне класса? Чем эти определения отличаются?
class A
{
	void method x{}
};

17. Можно в методах присваивать параметрам значения по умолчанию?
Да. Существуют дополнительные ограничения.

18. Что обозначается ключевым словом this?
Указатель на объект, который вызвал метод.

19. Зачем нужны константные методы? Чем отличается определение константного метода от обычного?
Чтобы предотвратить случайное изменение данных внутри метода и показать, что метод не меняет состояние класса.

20. Может ли константный метод вызываться для объектов-переменных? А обычный метод — для объектов-констант?
Да. Нет.

21. Объясните принцип полиморфизма.
Возможность работать с объектами разных классов одинаковым образом.
Поддержка различного поведения родственных классов, предоставляемого через единый интерфейс базового класса.
Есть статический - на этапе компиляции. Шаблоны, перегрузка функций и операторов.
Есть динамический - виртуальные функции. Точное значение операции определяется объектом для которого она вызывается.

22. Сколько места в памяти занимает объект класса? Как это узнать?
Столько, сколько все его поля, кроме статических, плюс размер указателя - информация о типе (1 char на gcc 32 bit).

23. Каков размер «пустого» объекта?
В типичной реализации - размер указателя. Это информация о типе.

24. Влияют ли методы на размер объекта?
Нет.

25. Одинаков ли размер класса и аналогичной структуры?
Да.

26. Какие операции нельзя перегружать? Как вы думаете, почему?
sizeof, ., .*, typeid ?:
потому что их операнд - это имя типа.

27. Можно ли перегружать операции для встроенных типов данных?
Нет, потому что тип - это набор данных и операций над ними. Изменяя семантику типа, мы меняем само определение типа.

28. Можно ли при перегрузке изменить приоритет операции?
Нет.

29. Можно ли определить новую операцию?
Нет. Надо пользоваться функциями.

30. Перечислите особенности перегрузки операций как методов класса. Чем отличается перегрузка внешним образом от перегрузки как метода класса?
На один параметр меньше, чем внешняя перегрузка.

31. Какой результат должны возвращать операции с присваиванием?
Ссылку.

32. Как различаются перегруженная префиксная и постфиксная операции инкремента и декремента?
Постфикс имеет фиктивный параметр.

33. Что означает выражение *this? В каких случаях оно используется?
Ссылка на объект.
Для разрешения неоднозначности, для определения размера.

34. Какие операции не рекомендуется перегружать как методы класса? Почему?
Те, которым не нужен доступ к внутренним переменным класса. Чтобы не нарушать инкапсуляции.

35. Какие операции разрешается перегружать только как методы класса?
Те, для которых нужна гарантия, что их первый операнд lvalue.
= [] ->

36. Дайте определение дружественной функции. Как объявляется дружественная функция? А как определяется?
Функция имеет доступ к закрытой части класса.
Не находится в области видимости класса.
Не должна вызываться для объекта класса.

37. Дайте определение конструктора. Каково назначение конструктора? Перечислите отличия конструктора от метода.
Специальный метод для инициализации объекта.
Не имеет возвращаемого значения. Не может быть статическим, виртуальным. Внутри не работает механизм виртуальных функций, потому что ещё не инициализирована таблица виртуальных функций.

38. Сколько конструкторов может быть в классе? Допускается ли перегрузка конструкторов? Какие виды конструкторов создаются по умолчанию?
Сколько угодно. Да. default ctor, copy ctor. 

39. Может ли конструктор быть приватным? Какие последствия влечет за собой объявление конструктора приватным?
Да. Невозможность конструирования объекта класса.

40. Приведите несколько случаев, когда конструктор вызывается неявно.
Копирование, конструирование внутренних объектов, передача по значению, приведение типа.

41. Как проинициализировать динамическую переменную?
в списке инициализаторов
new
placement new
new(nothrow)

42. Как объявить константу в классе? Можно ли объявить дробную константу?
const int x; const double x;

43. Каким образом разрешается инициализировать константные поля в классе?
статические интегральные прямо на месте, остальные в инициализаторе или вне класса, или в конструкторе

44. В каком порядке инициализируются поля в классе? Совпадает ли этот порядок с порядком перечисления инициализаторов в списке инициализации конструктора?
В порядке объявления. Нет.

45. Какие конструкции С++ разрешается использовать в списке инициализации качестве инициализирующих выражений?
rvalue, инициализированные lvalue

46. Какой вид конструктора фактически является конструктором преобразования типов?
Конструктор не explicit

47. Для чего нужны функции преобразования? Как объявить такую функцию в классе?
Для корректного приведения неродственных типов между собой.
Как операторы преобразования.
	static_cast - иерархическое преобразование с проверкой на этапе компиляции
	reinterpret_cast - несвязанное преобразование с проверкой на этапе компиляции
	dynamic_cast - проверяется на этапе выполнения RTTI.
	const_cast - аннулирует const и volatile
operator int() const {return v;}

48. Как запретить неявное преобразование типа, выполняемое конструктором инициализации?
explicit

49. Какие проблемы могут возникнуть при определении функций преобразования?
Если определены операторы и преобразования, то может возникнуть конфликт между неявным преобразованием и пользовательскими операторами.

50. Для чего служит ключевое слово explicit?
Это модификатор для запрещения неявного преобразования типов объектов аргументов конструктора.

51. Влияет ли наличие целочисленных констант-полей на размер класса?
Если не static, то да.

52. Разрешается ли объявлять массив в качестве поля класса. Как присвоить элементам массива начальные значения?
Да. В классе - только в конструкторе. Если статический константый, то вне пределов класса.

53. Сколько операндов имеет операция индексирования []? Какой вид результата должна возвращать эта операция?
Один. Любой. Чаще лучше ссылку.

54. Для чего нужны статические поля в классе? Как они определяются?
Для хранения состояния класса. static int i;

55. Как объявить в классе и проинициализировать статический константный массив?
class A { static const int I[3]; } A::I[3] = {1, 2};

56. Что такое выравнивание и от чего оно зависит? Влияет ли выравнивание на размер класса?
Расположение данных в памяти поблочно, так как процессор читает машинными словами. Зависит от реализации компилятора, ОЗУ и процессора. Влияет.

57. Дайте определение контейнера.
Контейнер - это объект, хранящий другие объекты.

58. Какие виды встроенных контейнеров в С++ вы знаете? На основе чего они реализованы
Фундаментальные последовательности
	vector
	list
	deque
Адаптеры
	stack - вектор
	queue - дек
	priority_queue - куча
Ассоциативные контейнеры и множества
	map - деревья
	multimap
	set
	multiset
Почти контейнеры
	string
	valarray
	bitset
	vector<bool>

59. Какие виды доступа к элементам контейнера вам известны?
Разыменовывание итератора и оператор индексирования, также специальные функции.

60. Чем отличается прямой доступ от ассоциативного?
Индексацией: целыми числами или значениями.

61. Перечислите операции, которые обычно реализуются для последовательного доступа к элементам контейнера.
begin(), end(), инкремент итератора, разыменование.

62. Дайте определение итератора.
Итератор это абстрактная модель данных, как последовательности объектов. Объект, который ведёт себя, как итератор - есть итератор. Ключевые концепции: инкремент, равенство и разыменование.

63. Можно ли реализовать последовательный доступ без итератора? В чем преимущества реализации последовательного доступа с помощью итератора?
Да. Единообразная работа с различными сущностями.

64. Что играет роль итератора для массивов С++?
Имя массива - указатель на начало и арифметика указателей.

65. Что такое деструктор? Может ли деструктор иметь параметры?
Специальная функция, отвечающая за уничтожение объекта. Нет.

66. Почему для классов-контейнеров деструктор надо писать явным образом?
Потому что управление переменной длиной конейнера требует динамического выделения памяти, которую, соответственно, надо уничтожать.

67. Допускается ли перегрузка деструкторов?
Нет, потому что он не имеет параметров.

68. Что такое «глубокое копирование» и когда в нем возникает необходимость?
Копирование значений полей класса, даже если они заданы указателями. При сериализации.

69. Какое копирование осуществляет стандартный конструктор копирования?
Вызывает конструкторы копирования баз и членов. Неглубокое копирование, если по умолчанию.

70. Чем отличается копирование от присваивания?
Это разные операции
Копирование - работает конструктор копирования, создаётся новый объект.
Присваивание - поля одного объекта заполняются значениями другого. Нового объекта не создаётся.

71. Объясните, почему в операции присваивания требуется проверка присваивания самому себе?
Не требуется, но рекомендуется. Для больших объектов весьма существенный выигрыш по времени.

72. Можно ли в качестве операции индексирования использовать операцию вызова функции ()? В чем ее преимущества перед операцией []?
Можно сделать это макросами. Можно сделать перегрузку оператора ()
Вызов с несколькими аргументами.

73. Почему необходимо писать два определения операции индексирования? Чем они отличаются?
Модификатором const. Нужно, чтобы была возможность изменять содержимое неконстантного контейнера и иметь доступ к константному.

74. Дайте определение вложенного класса.
Область видимости ограничена классом, в котором он объявлен.

75. Можно ли класс-итератор реализовать как внешний класс? А как вложенный? В чем отличия этих методов реализации?
Да. Да.
Во втором случае объект знает о типе итератора заранее.

76. Может ли объемлющий класс иметь неограниченный доступ к элементам вложенного класса? А вложенный класс — к элементам объемлющего?
Нет. Да.

77. Ограничена ли глубина вложенности классов?
Нет.

78. Можно ли определить вложенный класс внешним образом? Зачем это может понадобиться?
Да. Если вложенный класс нуждается в определении класса, в который он вложен. Или при раздельной трансляции.

79. Каким образом вложенный класс может использовать методы объемлющего класса? А объемлющий — методы вложенного?
Просто, вызывая их, если public.
Или сделав дружественный класс.

80. Что такое «запредельный» элемент, какую роль он играет в контейнерах?
Элемент, следующий за последним. Условие окончания перебора элементов.

81. Объясните, по каким причинам трудно написать универсальный контейнер, элементы которого могут иметь произвольный тип.
Из-за строгой типизации.

82. Назовите ключевые слова С++, которые используются для обработки исключений.
try, catch, throw

83. Исключение — это:
1) событие;
2) ситуация;
3) объект;
4) ошибка в программе;
5) прерывание;
	событие и объект, смотря с какой точки зрения.

84. Каким образом исключение генерируется?
Раскрутка стека. Поиск секции-обработчика.

85. Каковы функции контролируемого блока?
Отловить исключение, сгенерированное внутри него.

86. Что обозначается ключевым словом catch?
1) контролируемый блок;
2) блок обработки исключения;
3) секция-ловушка;
4) генератор исключения;
5) обработчик прерывания;
	2,3,5

87. Какого типа может быть исключение?
Любого. Это класс.

88. Сколько параметров разрешается писать в заголовке секции-ловушки?
Один.

89. Какими способами разрешается передавать исключение в блок обработки?
По значению, по ссылке или по указателю.

90. Объясните, каким образом преодолеть ограничение на передачу единственного параметра в блок обработки.
Завести класс, структуру или использовать несколько блоков обработки.

91. Почему нельзя выполнять преобразования типов исключений при передаче в секцию-ловушку?
Потому что может сработать не та ловушка.

92. Напишите конструкцию, которая позволяет перехватить любое исключение.
catch(...){}

93. Могут ли контролируемые блоки быть вложенными?
Да.

94. Зачем нужен «контролируемый блок-функция» и чем он отличается от обычного контролируемого блока?
Нужен для перехвата исключения в списке инициализации конструктора. Используется для преобразования типа исключения: ловится одно, кидается другое.
class X {
	vector v;
public:
	explicit X(int);
};
X::X(int s)
try
	:v(s)
{
	//...
}
catch(bad_alloc)
{
	//...
}

95. Перечислите возможные способы выхода из блока обработки.
Нормальный выход, генерация исключения, передача сгенерированного исключения.

96. Каким образом исключение «передать дальше»?
throw

97. Сколько секций-ловушек должно быть задано в контролируемом блоке?
Сколько угодно. Главное - правильная последовательность.

98. Что такое «спецификация исключений»?
Это часть объявления функции, которая указывает набор генерируемых ею исключений и производных от них.
void fu(int a) throw(x2, x3);

99. Что происходит, если функция нарушает спецификацию исключений?
вызовется std::unexpected() и программа завершит работу terminate().

100. Учитывается ли спецификация исключений при перегрузке функций?
Спецификация должна быть не менее строгой.
Потомок может генерировать производные исключения.

101. Что такое «иерархия исключений»?
То же, что иерархия классов.

102. Существуют ли стандартные исключения? Назовите два-три типа стандартных исключений.
Да. 
exception	<- logic_error		<- domain_error 
								<- invalid_argument 
								<- length_error 
								<- out_of_range 
			<- runtime_error	<- range_error 
								<- overflow_error 
								<- underflow_error

103. Поясните «взаимоотношение» исключений и деструкторов.
Объект уничтожается в конце его области видимости, если сгенерировалось исключение. Деструктор отрабатывает.

104. Объясните, зачем может понадобиться подмена стандартных функций завершения.
Для собственной обработки ситуаций (обычно для записи в лог).

105. Какие виды нестандартных исключений вы знаете?
Нестандартные - потому что не успели включить в стандарт?

106. В чем отличие механизма структурной обработки исключений Windows от стандартного механизма?
этот механизм называется SEH. предоставляет две схемы обработки. __try{} __except{} и __try{} __finally{}
в SEH существует только единственный обработчик.
Описано у Рихтера.

107. Какие две роли выполняет наследование?
Формирует иерархию и поощряет повторное использование кода.

108. Какие виды наследования возможны в С++?
Обычное, множественное, виртуальное.

109. Чем отличается модификатор доступа protected от модификаторов private и public?
Видимостью наследующему классу.

110. Чем открытое наследование отличается от закрытого и защищенного?
Имя класса может использоваться в разных местах.

111. Какие функции не наследуются? Почему?
Конструкторы и оператор присваивания. Потому что если они не определены, они генерируются компилятором.

112. Сформулируйте правила написания конструкторов в производном классе.
Если базовый класс имеет конструктор, он должен быть вызван.

113. Каков порядок вызова конструкторов? А деструкторов?
В обратном порядке: (стек)
	Базовые виртуальные классы
	Таблица виртуальных классов.
	Базовые классы.
	Таблица виртуальных функций.
	Члены
	Сам класс
У деструктора наоборот

114. Можно ли в производном классе объявлять новые поля? А методы?
Да. Да.

115. Если имя нового поля совпадает с именем унаследованного, то каким образом разрешить конфликт имен?
Оператор доступа к области видимости ::

116. Что происходит, если имя метода-наследника совпадает с именем базового метода?
Происходит перекрытие имён.

117. Сформулируйте принцип подстановки.
Замена в программе объектов некоторого типа на объекты подтипа этого типа не должна приводить к изменениям в поведении программы.
Также подразумевается, что методы подкласса не могут выбрасывать исключений, кроме подклассов исключений, выбрасываемых базовым типом.
Функции, которые используют ссылки на базовые классы, должны иметь возможность использовать объекты производных классов, не зная об этом.

118. Когда выполняется понижающее приведение типов?
Когда у программы плохой дизайн :)
При передаче в функцию объекта подтипа базового.

119. Объясните, что такое «срезка» или «расщепление».
Случай, когда в присваивании участвует два объекта из разных уровней одной иерархии. Одному из объектов присваивается только базовая часть (то, что он знает) от другого объекта.
Или, например, передача по значению в функцию класса наследника.

120. Объясните, зачем нужны виртуальные функции.
Для реализации динамического полиморфизма.

121. Что такое связывание?
Определение того, какая функция должна быть вызвана. То есть, компоновка.
Тип связывания или тип компоновки определяет соответствие имени объекту или функции в программе, исходный текст которой располагается в нескольких модулях. Различают статическое и динамическое связывание. 
Статическое связывание бывает внешним или внутренним. Оно обеспечивается на стадии формирования исполнительного модуля, ещё до этапа выполнения программы. 
Если объект локализован в одном модуле, то используется внутреннее связывание. Тип компоновки специальным образом не обозначается, а определяется компилятором по контексту, местоположению объявлений и использованию спецификаторов класса памяти. 
Внешнее связывание выполняется компоновщиком, который на этапе сборки многомодульной программы устанавливает связь между уникальным объектом и обращениями к объекту из разных модулей программы. 
При динамическом связывании компоновщик не имеют никакого представления о том, какой конкретно объект будет соответствовать данному обращению. Динамическое связывание обеспечивается транслятором в результате подстановки специального кода, который выполняется непосредственно в ходе выполнения программы.
В Си глобальные переменные по умолчанию имеют внутреннее связывание. В си-плюсплюс - наоборот, внешнее. И то и другое, разумеется, если квалификатор не задан явно.
Ключевое слово extern выводит за пределы области видимости единицы трансляции.

122. Чем «раннее» связывание отличается от «позднего»?
На этапе компиляции - разрешение перегрузки. На этапе выполнения - виртуальные функции.

123. Какие два вида полиморфизма реализованы в С++?
Статический и динамический. Шаблоны и виртуальные функции.

124. Дайте определение полиморфного класса.
Класс с виртуальными функциями.

125. Может ли виртуальная функция быть дружественной функцией класса?
Да.

126. Наследуются ли виртуальные функции?
Да.

127. Каковы особенности вызова виртуальных функций в конструкторах и деструкторах?
В конструкторе не работают. Потому что объект ещё до конца не создан, следовательно нет таблицы виртуальных функций.

128. Можно ли сделать виртуальной перегруженную операцию, например, сложение?
Да.

129. Может ли конструктор быть виртуальным? А деструктор?
Нет. Да.

130. Как виртуальные функции влияют на размер класса?
Указатель на таблицу виртуальных функций для каждого объекта. Таблица виртуальных функций для каждого класса. В целом - никак.

131. Как объявляется «чистая» виртуальная функция?
Присваивается 0.
class A { virtual void d() = 0; }

132. Дайте определение абстрактного класса.
Класс, содержащий только чистые виртуальные функции.

133. Наследуются ли чистые виртуальные функции?
Да.

134. Можно ли объявить деструктор чисто виртуальным?
Да. Деструктор должен быть определён.

135. Чем отличается чистый виртуальный деструктор от чистой виртуальной функции?
Он обязан иметь определение.

136. Зачем требуется определение чистого виртуального деструктора?
Чтобы корректно удалять объекты по ссылке типа базового класса.
Например, если это единственный метод, а создание класса нужно запретить.

137. Наследуется ли определение чистой виртуальной функции?
Нет. У чистой виртуальной функции нет смысла в определении.

138. Приведите классификацию целей наследования.
Наследование интерфейса и наследование реализации.

139. Объясните разницу наследования интерфейса от наследования реализации.
В первом случае наследуются объявления функций, во втором - поля и алгоритмы.

140. Назовите причины, требующие разделения программ на части.
Уменьшение времени на компиляцию, борьба со сложностью, ODR.

141. Дайте определение термина «единица трансляции»?
Результат обработки препроцессором исходного файла с кодом.

142. Чем отличается файл с исходным текстом от единицы трансляции?
Первое - это то, что видит программист. Второе - то, что обрабатывает компилятор.

143. Существуют ли в С++ конструкции, позволяющие идентифицировать отдельный модуль?
Пространство имён, неименованное пространство имён.

144. Какие способы сборки программы вы можете назвать?
Полная перекомпоновка и частичная сборка.

145. Что такое «объектный модуль»? Программа, которая «собирает» объектные модули в программу, называется _____________ ?
Транслированный код единицы трансляции с таблицами экспорта.
Линковщик.

146. В чем заключается отличие аргумента «файл» от <файл> в директиве #include?
Локальные и глобальные подключения.

147. Что такое ODR?
Правило одного определения. One definition rule. Каждый пользовательский тип должен быть определён в программе ровно один раз.

148. Объясните, что такое «страж» включения и зачем он нужен.
Это конструкция из #ifdef SYMBOL
Нужна для предотвращения повторного включения и соблюдения ODR

149. Является ли интерфейс класса его определением?
Нет. Это его объявление.

150. Сколько определений класса может быть в единице трансляции?
Одно.

151. Сколько определений класса может быть в многофайловой программе?
Несколько, если они идентичны.

152. Чем отличаются стандартные заголовки <string>, <string.h> и <cstring>?
STL, CRT, CRT

153. Объясните суть идиомы Pimpl.
В классе хранится указатель на реализацию. Реализация скрыта от пользователя.

154. Что такое делегирование и как его можно использовать для повышения степени инкапсуляции?
Это спецификация множества операций, которые не определены для одного класса и должны обслуживаться другим. Можно хранить указатель на другой класс и ссылаться на него в функциях.
Разделяет сферы ответственности.

155. Каким образом глобальную переменную, определенную в одной единице трансляции, сделать доступной в другой единице трансляции? А константу?
определение int x = 10; доступность extern int x;
определение extern const int x = 10; доступность extern const int x;

156. Можно ли использовать слово extern при объявлении функций?
Да.

157. Как локализовать объявление функции в файле?
Использовать static(внутреннюю компоновку) или неименованные пространства имён(предпочтительно)

158. Чем отличается «внешнее» связывание от «внутреннего» связывания?
Внутренее связывание происходит тогда, когда объект локализован в одном модуле.
Внешнее связывание - установка линкером связи между объектом и обращениями к нему.

159. Что такое «спецификации компоновки»?
Нотация, позволяющая компоновать объектные модули, написанные на разных языках программирования.
Например, соглашения о вызове функций(порядке помещения параметров в стек).

160. Какие объекты обладают внутренним связыванием по умолчанию?
Неглобальные переменные

161. Какие области видимости имен вы знаете?
Глобальная, в пределах единицы трансляции, в пределах класса, в пределах функции, в пределах тела цикла.

162. Для чего используются пространства имен?
Для управления сложностью и разделения программы на части. Для избегания глобальных переменных.

163. Чем отличаются именованные и неименованные пространства имен?
В неименованных namespaces доступ к объявленным в них именам возможен только из той же единицы трансляции, где определено namespace.

164. Могут ли пространства имен быть вложенными?
Да.

165. Для чего применяются алиасы пространства имен?
Для удобства использования и чтобы избежать конфликта имён.

166. Как сделать члены пространства имен доступными в нескольких (в пределе — во всех) файлах программного проекта?
using namespace xxx;

167. Объясните разницу между статической и динамической инициализацией.
Значение известно на этапе компиляции/выполнения.

168. В чем состоит проблема инициализации глобальных статических переменных?
В том, что порядок инициализации неизвестен.

169. Какие элементы класса можно объявлять статическими?
Методы, операторы, члены

170. Можно ли объявить в классе статическую константу? А константный статический массив?
Да. Да.

171. А какие статические поля можно инициализировать непосредственно в классе?
Статические интегральные константы.

172. Как определяются статические поля? В какой момент работы программы выполняется инициализация статических полей?
ключевое слово static
до вызова main

173. Сколько места в классе занимают статические поля ?
0

174. Чем отличается статический метод от обычного?
нет this

175. Какие методы класса не могут быть статическими?
Конструкторы, деструкторы, виртуальные функции

176. Какие применения статических полей вы можете привести? А каким образом применяются статические методы?
Счётчик экземпляров. Состояние класса.
Функция, создающая объекты.

177. Приведите структуру и принцип действия паттерна Singleton.
Класс с приватным конструктором. Имеет функцию для возврата объекта. Хранит объект в себе.
Общая проблема реализации паттерна - время жизни.

178. Для чего предназначены шаблоны?
Для реализации типонезависимых алгоритмов и для метапрограммирования.

179. Какие виды шаблонов в С++ вы знаете?
Шаблоны классов и шаблоны функций.

180. Объясните термин «инстанцирование шаблона».
Процесс генерации объявления по шаблону.

181. В чем разница между определением и объявлением шаблона?
В том же, что и между определением и объявлением функции или класса.

182. Объясните назначение ключевого слова typename.
Чтобы заявить о том, что именованная сущность - это тип. Используется, чтобы указать на вложенный в шаблоне тип, зависящий от параметра шаблона.
Может быть использовано вместо слова class в объявлении шаблона.

183. Какие виды параметров разрешается задавать в шаблоне класса? А в шаблоне функции?
Типы(typename, class), обычные типы(int), шаблоны

184. Можно ли параметрам шаблона присваивать значения по умолчанию?
Да.

185. Может ли параметром шаблона быть другой шаблон? Каковы особенности объявления параметра-шаблона?
Да.
Нужно знать тип инстанцирования шаблона.

186. Что такое специализация шаблона? Объясните разницу между полной и частичной специализацией.
Частный случай некоторого шаблона при фиксированной части аргументов. Частичная специализация - часть аргументов фиксирована. Полная - все аргументы фиксированы.

187. Разрешается ли специализировать шаблон функции?
Да, но только полностью. Частичная специализация - это перегрузка.

188. Может ли класс-шаблон быть вложенным в другой класс-шаблон? А в обычный класс?
Да. Да.

189. Можно ли объявить в классе шаблонный метод? А шаблонный конструктор?
Да. Да.

190. Можно ли перегружать функцию-шаблон?
Да.

191. Какие параметры функции-шаблона выводятся автоматически?
Простые типы. Если совпадение с типом элементов аргумента массива.

192. Может ли шаблон класса быть наследником обычного класса? А обычный класс от шаблона?
Да. Нет.

193. Объясните, что такое класс свойств (класс трактовок).
Параметры шаблонов, используемые для выбора того или иного алгоритма.

194. Каким образом можно использовать возможность наследования обычного класса от шаблона?
Создавать типонезависимые интерфейсы к внутреннему средству.

195. Может ли шаблонный конструктор быть конструктором по умолчанию?
Нет.

196. Для чего применяются директивы явного инстанцирования?
Чтобы соответствующий экземпляр был скомпилирован/слинкован. При объявлении инстанцированного типа.

197. Объясните, в чем состоят проблемы, возникающие при разделении шаблонного класса на интерфейс и реализацию?
Реализация не может быть вынесена в cpp файл (так как экспорт шаблонов не поддерживается большинством компиляторов)

198. Что такое «модель явного инстанцирования» и как она работает?
Реализация вынесена в cpp файл и есть явные экземпляры для нужных типов.
Например, template basic_string<char> string;

199. Может ли шаблонный класс иметь «друзей»?
Да.

200. Какие проблемы возникают при объявлении дружественной функции для класса-шаблона?
Заранее неизвестен тип, с которым ведётся работа.

201. Разрешается ли определять в классе-шаблоне статические поля? А статические методы?
Да. Да.

202. Что такое «инициализация нулем»?
Инициализация объекта значением 0, преобразованным в тип объекта.

203. Что является единицей памяти в С++? Какие требования к размеру единицы памяти прописаны в стандарте С++?
Байт. Это самая малая величина, достаточная для хранения самых маленьких базовых типов С++. Каждый байт - непрерывная последовательность бит, имеющая уникальный адрес.

204. В каких единицах выдает результат операция sizeof? Какие типы данных имеют размер 1?
В единицах char.
все виды char, пустой объект и указатель

205. Какие три вида памяти входят в модель памяти С++?
Статическая
Автоматическая(стек)
Свободная(куча)

206. Сколько видов динамической памяти обеспечивает С++?
Автоматическая и свободная(стек и куча)

207. Какие функции для работы с динамической памятью достались С++ по наследству от С? В какую библиотеку они включены?
семейство alloc и free
cstdlib

208. Какие функции выделяют память, и с помощью каких функций память освобождается?
malloc, free

209. Какое важное отличие имеет функция calloc() от функции malloc()?
Обнуление выделенной памяти.

210. Какие действия выполняют функции выделения памяти, если память не может быть выделена?
Возвращают NULL.

211. Зависит ли объем выделенной памяти от типа указателя? Влияет ли выравнивание на объем выделяемой динамической памяти?
Нет. Да.

212. Можно ли с помощью функции realloc() уменьшить объем выделенной памяти?
Да.

213. Что произойдет, если функции free() передать в качестве аргумента нулевой указатель?
Ничего.

214. В чем главное отличие объектно-ориентированного механизма new/delete от механизма malloc()/free()?
Он оперирует на уровне объектно-ориентированной абстракции, а не на машинном уровне. Машинная низкоуровневая модель рассматривает память как массив битов. Высокоуровневая модель, как объект.

215. Сколько существует форм new/delete? В чем их отличие?
new, new[], delete, delete[]
Возможность создавать массив объектов.
есть операторы с размещением, есть с параметром nothrow

216. Какие типы являются POD-типами? Чем отличается работа механизма new/delete с POD-объектами и nonPOD-объектами?
Plain old data. Те типы, которые есть в С. Классы или структуры, содержащие только POD-поля.
new X - не инициализируется
new X() - инициализируется

217. Какие функции выполняет обработчик new?
Пытается найти память в случае неудачи при помощи new_handler или просто возвращает исключение.

218. Можно ли реализовать собственный обработчик new и «прицепить» его к механизму new/delete?
Да. set_new_handler()

219. В чем главное отличие объединения от других видов классов С++?
Это структура, в которой все члены расположены по одному и тому же адресу.

220. Может ли объединение участвовать в иерархии наследования? Что такое анонимное объединение?
Нет. Объединение без имени, в области видимости структуры.

221. Разрешается ли определять для объединения конструкторы и деструктор? А виртуальные функции?
Нет. Нет.

222. В чем похожи и чем отличаются объединение и размещающий new?
Похожи моделью "конкретный кусок памяти - размещаю в нём, что хочу". Отличаются - объединение интерпретирует кусок памяти по-разному.

223. Объясните, почему при использовании размещающего new нужно явным образом вызывать деструктор?
Потому что мы помещаем объект в область, которая явно не управляется стандартным распределителем памяти.

224. Зачем нужны интеллектуальные указатели?
Для облегчения управления памятью.
Для реализаций стратегий владения.

225. Что такое «стратегия владения»? Сколько стратегий владения вы знаете?
Способ, которым умные указатели ссылаются на объект
	Глубокое копирование - копирование объекта на который он ссылается
	копирование при записи - копирование объекта происходит только при первой попытке его модификации
	подсчёт ссылок - подсчёт указателей, ссылающихся на объект. когда 0 - сборка мусора
	разрушающее копирование - можно быть уверенным, что если в вызывающем модуле значение не используется, оно уничтожается.
	связывание ссылок - нет необходимости считать указатели, получается список владельцев(полезно при недостатке динамической памяти).

226. Какой интеллектуальный указатель реализован в стандартной библиотеке STL, и какую стратегию владения он реализует?
auto_ptr, разрущающее копирование

227. Объясните, в чем преимущества и недостатки интеллектуальных указателей со счетчиком ссылок.
Простая стратегия. Потеря скорости и неэффективность работы с памятью.

228. Разрешается ли перегружать new и delete и какими способами?
Разрешается. Локально, в классе и глобально.

229. Опишите схему функции, перегружающей глобальную функцию new.
void *operator new(size_t size(){}
void operator delete[](void *p);

230. Отличается ли реализация перегруженной функции new[]() для массивов от реализации «обычной» функции new()?
Да. Указатель на объект отличается от указателя на первый элемент массива, как в С.

231. Как вы думаете, почему функции new/delete, перегружаемые для класса, являются статическими?
Потому что они выделяют память для объекта, то есть, создают его.

232. Зачем при перегрузке new/delete для класса нужно проверять размер запрашиваемой памяти?
Потому что операторы наследуются и могут быть вызваны потомками.

233. Объясните, чем определяется «динамичность» контейнеров?
Распределителями памяти? Что за вопрос вообще?

234. Что такое «стратегия распределения памяти», и какие стратегии выделения памяти вы знаете?
Алгоритм выделения блоков памяти.
Первый походящий, последний подходящий, наиболее подходящий.

235. Рассмотрите следующую стратегию распределения памяти: память выделяется для нескольких элементов блоками фиксированной длины, но блоки связываются в список. Для какого вида контейнера можно использовать такую стратегию?
list

236. Какие операции можно перегрузить для доступа к элементам двумерного массива?
()

237. В чем заключаются сложности использования операции индексирования [] для доступа к элементам двумерного массива?
Необходимо знать размеры массива по обе стороны

238. Каковы способы реализации операций с контейнерами?
алгоритм+итератор+функтор

239. Какую конструкцию можно назвать «обобщенный алгоритм»?
Шаблон.

240. Каким образом объявить указатель на метод?
typedef char* (Someclass::*func_ptr)(int, char*);

241. Объясните разницу между указателем на функцию и указателем на метод.
Указатель на функцию - глобально. Указатель на метод - для конкретного типа. Указатели на методы с одинаковой сигнатурой, но для разных типов являются разными указателями.

242. Каким образом получить адрес метода?
&Class::somefunc;

243. Можно ли указателю на функцию присваивать адрес метода?
Нет.

244. Какие операции определены в С++ для косвенного вызова метода через указатель?
.* ->*

245. Что такое «функтор»? Приведите пример функционального класса.
Объект, который рассматривается, как функция. Объект класса с оператором ().
class Functor
{
	bool operator()(int x) {return static_cast<bool>(x);}
};

246. Какими способами функтор вызывается?
Передача в качестве параметра и как функция.

247. Можно ли использовать наследование при разработке функторов?
Да.

248. Разрешается ли операцию вызова функции () определять как виртуальный метод? А как статический?
Да. Нет.

249. В чем преимущества функторов перед указателями на функции?
поддержка обобщённого программирования
сохранение данных между вызовами, плюс операции инициализации этих данных
операцию () проще сделать встроенной, чем указатель на функцию

250. Объясните, зачем нужны адаптеры функторов? Какие виды адаптеров вы знаете?
Решают задачу, когда нужен новый предикат, который во многом похож на старый.
Связыватель, адаптер методов, адаптер указателя на функцию, отрицатель

251. Как используются классы свойств при разработке функторов?
Позволяют настраивать функтор.

252. Объясните, что такое «композиция» и приведите примеры?
Это один из способов реализации отношения "содержит". Сделать один класс членом другого. Через закрытое наследование - другой способ. Отношения "является" - открытое наследование.

253. Объясните, чем отличается множественное наследование от простого?
Один родитель и много родителей.

254. Приведите структуру и принцип действия паттерна Adapter.
Паттерн вносит ограничения или привносит функциональность в сущность, адаптируя её под работу в конкретных условиях.

255. Сформулируйте основную проблему множественного наследования.
Проблема неоднозначности и совокупного хранения нескольких объектов базового класса.
Комбинаторное по своей природе, множественное наследование нельзя применять для поддержки многовариантных систем.
Нарушает принцип подстановки.

256. Выполняется ли принцип подстановки при открытом множественном наследовании?
Да, если наследование проведено корректно.

257. Что такое виртуальное наследование? Каковы его преимущества и недостатки по сравнению с обычным наследованием?
Это множественное наследование, при котором нескольким классам, имеющим один базовый всегда сопоставляется один объект этого базового класса.
Преимущества - экономия памяти.

258. Может ли виртуальное наследование быть одиночным?
Да.

259. Влияет ли виртуальное наследование на размер класса?
Да. Уменьшает размер итогового класса.

260. Объясните, каким образом с помощью виртуального наследования можно вообще запретить наследование.
class my_class;

class nonderivable
{
	friend class my_class;
private:
	nonderivable() { }
};

class my_class: public virtual nonderivable
{
public:
	my_class(){}
};

class DD: public my_class { };

int main()
{
	my_class a;
	DD dd; // error
	return 0;
}

261. Какие средства С++ составляют RTTI?
dynamic_cast, typeid

262. Объясните разницу между повышающим, понижающим и перекрестным приведением.
Приведение к базовому типу, к потомку, к родственному классу в иерархии

263. Какими свойствами должен обладать класс, чтобы с ним работал механизм RTTI?
Быть полиморфным типом.

264. В чем приведение указателей отличается от приведения ссылок?
dynamic_cast генерирует исключение, если ссылка, если указатель, то просто возвращает 0

265. Какие исключения связаны с механизмом RTTI?
Можно отлавливать целую группу исключений и определять, что это за подтип базового типа при помощи dynamic_cast

266. Что такое «поток» — дайте определение.
Часть процесса, выполняющаяся параллельно (или псевдопараллельно).
Средство ввода-вывода С++

267. Как классифицируются потоки, реализованые в библиотеках ввода/вывода С++?
По направлению: ввод, вывод
По типу объекта: строковые, файловые

268. Что такое буферизация и зачем она нужна?
Это техника оптимизации, заключающаяся в накапливании достаточно большой порции данных и последующей их передаче на обработку.

269. Какие библиотеки ввода/вывода реализованы в С++ и чем они отличаются?
<iostream> - ОО модель
<cstdio> - С модель

270. Перечислите стандартные потоки и объясните их назначение.
stdin, stdout, stderr
идентификаторы 0,1,2

271. Зачем нужен процесс форматирования и когда он выполняется?
Он нужен для ввода-вывода данных с наложенными на них ограничениями. Выполняется тогда, когда мы работаем с данными ожидаемой структуры.

272. Что такое «форматная строка», и в каких функциях она используется?
Строка, задающая формат интерпретации переменных. Используется в вводе-выводе в стиле С.

273. Объясните назначение элементов спецификатора формата.
указывают тип, поля и точность вывода
% - указывает, что следующий за ним символ будет спецификатором формата
g - точность вывода числа с плавающей точкой определяется реализацией
e - научный формат вывода
f - фиксированный знак после запятой
i - целое число
c - символ
s - строка

274. Сколько спецификаторов формата может быть в форматной строке?
Сколько угодно (на сколько памяти хватит)

275. Какой из элементов спецификатора формата не является умалчиваемым?
Ширина поля #

276. Перечислите несколько известных вам обозначений типов в спецификаторе формата, и укажите их назначение.
g - точность вывода числа с плавающей точкой определяется реализацией
e - научный формат вывода
f - фиксированный знак после запятой
i - целое число
c - символ
s - строка

277. Сколько модификаторов типа вы знаете, и какую роль модификатор типа играет в спецификаторе формата?
c,d,i,o,x,f,e,g

278. С помощью какого флага можно выровнять выводимое значение влево? А каким образом вывести ведущие нули?
ios_base::left
ios_base::showpoint

279. Какое действие оказывают на выводимую строку ширина, точность и флаги в спецификаторе формата?
Ширина - не менее стольки-то симолов. Точность - забивает нулями недостаток, флаги - выравнивают

280. Для чего в спецификаторе формата может использоваться символ звездочка («*»)? Чем отличается действие этого символа при воде и при выводе?
Ширина поля. При вводе "не менее стольки-то" при выводе обрезает.

281. Каковы особенности ввода строк?
Если вводить в массив символов, а не в str - риск переполнения.
Строка считывается до символа-разделителя, поэтому чтобы считать строку с пробелами, необходимо использовать getline()
Символы-разделители определяются isspace(), которая определена в <cctype>

282. Каким образом ограничить набор вводимых символов при вводе?
get(буфер, количество символов)
или через строковые потоки - применить флаг

283. Что является главной проблемой при использовании форматного ввода/вывода из библиотеки <cstdio>?
Переполнение буфера, так как это функции с переменным количеством аргументов.

284. Объясните, для чего нужны строковые потоки. Почему строковые потоки - всегда форматируемые?
Для форматирования в памяти.

285. С помощью каких функций выполняется работа со строковыми потоками?
operator<< operator>>

286. Можно ли использовать тип string (и каким образом) со строковыми потоками?
Получить итоговую строку.

287. Объясните, в чем заключается различие между текстовым и двоичным файлом.
В интерпретации содержимого. Двоичный файл - "сырые данные", свободная интерпретация. Тестовый файл - определённая структура (фиксированный набор символов, символы-разделители, и.т.д.)
Текстовый файл можно интерпретировать, как двоичный, а вот двоичный, как текстовый - не всегда.

288. Объясните, что означает «открыть» файл и «закрыть» файл?
Связать файл с дескриптором, который обращается к буферу в памяти, куда подгружается содержимое файла с диска. 
В двух словах "перекачать файл в память с диска.

289. Каким образом внешний файл связывается с потоком?
Созданием объекта класса.

290. Можно ли один и тот же поток связать с разными файлами? А один и тот же файл с разными потоками?
Нет. Да, с флагами общего доступа.

291. Перечислите режимы открытия файла. Чем отличается режим “r” от режима “a”?
r a w и их комбинации
первый читает, но не пишет, второй может читать и  добавлять в конец

292. Какую роль в режиме открытия играет знак плюс («+»)?
Добавление в конец

293. В каких случаях необходимо следить за ситуацией «конец файла»? Каким способом это делается?
Когда идёт поблоковое чтение. Специальной функцией или итератором, смотря что используется.

294. Можно ли текстовый файл открыть как двоичный? А двоичный — как текстовый?
Да.Да.

295. Какие функции ввода/вывода используются для обмена с текстовыми файлами?
fprintf
fscanf

296. Перечислите функции ввода/вывода для работы с двоичными файлами.
fget
fput

297. Какие функции реализованы в библиотеке <cstdio> для обеспечения прямого доступа к записям двоичного файла? Можно ли их использовать для работы с текстовыми файлами?
fseek, fread, fwrite
Можно.

298. Объясните назначение функции fseek().
Передвигать текущую позицию чтения-записи в файле.

299. Чем отличается функция ftell() от функции fgetpos()?
Первая ищет смещение от начала потока, вторая может искать от конца, начала и текущей позиции.

300. Объясните, что означает «перенаправление» потока? Какие потоки можно перенаправлять и куда?
Вывод данных на другое заданное устройство, нежели предполагалось вначале. поток ввода, поток вывода, поток ошибок. На любое блочное или символьное устройство, будь то терминал или файл. С точки зрения С++ - это копирование буфера.
любой в любой

301. Каким образом перенаправление ввода можно использовать для ввода строк с пробелами?
Перенаправить в стрингстрим.

302. В чем преимущества объектно-ориентированной библитеки по сравнению с процедурной?
Если имеется в виду вывод - безопасность с точки зрения типов и общий стиль для вывода как встроенных, так и пользовательских типов.

303. В каких состояних может находиться поток? Каким образом отслеживается состояние «конец потока»?
good, bad, fail
итератором

304. Какие объектно-ориентированные потоки связаны со стандартными потоками?
cin, cout, cerr, clog

305. Чем отличаются объектно-ориентированные строковые потоки от процедурных строковых потоков?
Нет опасности переполнения

306. Каким образом строковые потоки можно использовать для ограничения ширины поля ввода? А можно ли с той же целью использовать строковые потоки <cstdio>?
задать width()
Да. Спецификатор *

307. Сравните средства форматирования объектно-ориентированной и процедурной библиотеки.
ОО - манипуляторы. Действуют для потока.
ПРОЦ - строка форматирования. Действует для конкретного ввода.

308. Каким образом ввести строку типа string с пробелами?
Функция getline()

309. Каково назначение флагов форматирования? Какие средства реализованы в библиотеке для работы с флагами форматирования?
Управляют форматированием ввода-вывода.

310. Что такое «манипулятор»? В чем преимущества манипуляторов перед флагами форматирования?
Функция для установки состояния потока. Когда операции записываются, как инструкции, логические связи между ними не очевидны.

311. Как связываются файлы с потоками в объектно-ориентированной библиотеке?
Через конструктор и деструктор.

312. Можно ли файлы, записанные функциями библиотеки <cstdio>, прочитать объектно-ориентированными средствами? А наоборот?
Да. Да.

313. Перечислите режимы открытия объектно-ориентированных файловых потоков. каким образом комбинируются режимы открытия файлоавых потоков?
чтение, запись, добавление в конец, двоичный, поиск конца
побитовым "ИЛИ"

314. Обязательно ли закрывать файл, связанный с объектно-ориентированным файловым потоком? А открывать?
Достаточно создать объект класса потока.

315. Каким образом открыть файловый поток для чтения и записи одновременно?
объявить объект типа std::fstream и добавить соответствующие флаги.

316. Как открыть файловый поток для дозаписи?
ios_base app

317. Можно ли вывести значение переменной в двоичном виде и как это сделать?
int i = 938745;
cout << bitset<32>(i);
Или через флаги.

318. Разрешается ли наследовать от классов библиотеки ввода/вывода?
Да.

319. Каким образом можно перенаправить объектно-ориентированный поток?
class redirecter
{
public:
    redirecter(std::ostream & dst, std::ostream & src)
        : src(src), sbuf(src.rdbuf(dst.rdbuf())) {}
    ~redirecter() { src.rdbuf(sbuf); }
private:
    std::ostream & src;
    std::streambuf * const sbuf;
};

int main()
{
    std::ofstream log("hello-world.log");
    redirecter redirect(log, std::cout);
    std::cout << "Hello, world!\n";
    return 0;
}

320. Как используется буфер потока для копирования потока?
ostream dst; istream src;
dst << src.rdbuf();

321. Какими операциями выполняется форматированный ввод/вывод в файловые потоки? А неформатированный?
fprintf, fscanf
fread, fwrite

322. Реализованы ли в объектно-ориентированной библиотеке средства прямого доступа к файловым потокам? Сравните их с аналогичными средствами библиотеки <cstdio>.
Да.

323. С какими объектно-ориентированными потоками разрешается, и с какими не разрешается использовать средства прямого доступа?
iostream - разрешено
stringstream - запрещено

324. Покажите, каким образом можно выполнить перегрузку операций ввода/вывода для нового типа данных.
class A
{
public:
	int getField(){return i;}
	int setField(int i) { this->i = i; }
	A(int i):i(i);
private:
	int i;
};
std::ostream& operator<<(std::ostream& s, A a) { s << a.getField(); return s; }
std::istream& operator>>(std::istream& s, A a) { int i = 0; s >> i; a.setField(i); return s; }

325. Как выполняется обработка ошибок ввода/вывода в объектно-ориентированной библиотеке?
Исключения или флаги состояния потока

326. Какое стандартное исключение генерируется при ошибках ввода/вывода? Обязательно ли оно генерируется?
ios_base::failure
не всегда. Надо попросить об этом, например, cout.extensions(ios_base::badbit|ios_base::eofbit);

327. Чем стандартные широкие потоки отличаются от узких?
Оперируют расширенными символами (юникод) wchar_t, например.

328. Что такое — «локаль», и каково ее назначение?
Объект, который контролирует классификацию символов и устанавливает порядок их следования.
Поддержка соглашений, принятых в другой культуре.

329. Как установить русский шрифт при выводе в консольное окно?
например:
locale loc("ru_RU.UTF8");
locale::global(loc);

330. отличается ли ввод/вывод широких файловых потоков от узких? Чем?
На уровне интерфейса - нет.

331. Перечислите все последовательные контейнеры стандартной библиотеки. Чем они отличаются друг от друга?
vector - непрерывная в памяти последовательность, операции с концом вектора и индексация О(1), вставка в середину O(n)
list - вставка в начало и конец за постоянное время, доступ к элементам за линейное
dequeue - вставка в оба конца за постоянное время, индексация приближённо как у вектора

332. Перечислите адаптеры последовательных контейнеров и дайте их подробную характеристику.
queue, stack, priority_queue

333. Почему для адаптеров-очередей нельзя использовать вектор в качестве базового?
У вектора нет pop_front

334. Чем простая очередь queue отличается от приоритетной очереди priority_queue?
В приоритетной очереди операция извлечения ориентируется не только на положение элемента, но и на результат операции сравнения.

335. Каким требованиям должны удовлетворять элементы контейнера?
Должна поддерживаться операция копирования, похожая на встроенные типы. Для ассоциативных контейнеров должно поддерживаться сравнение (по умолчанию <), определяющее строгое слабое упорядочивание.

336. Могут ли быть указатели элементами контейнера? А итераторы?
Да. Теоретически может, есть опасность получить неверный итератор.

337. Почему нельзя использовать в качестве элементов контейнера стандартный интеллектуальный указатель auto_ptr?
Потому что операция копирования auto_ptr зануляет исходный указатель

338. Зачем в контейнере list реализованы собственные методы сортировки поиска и слияния? Можно ли пользоваться соответствующими стандартными алгоритмами при обработке списка?
Потому что алгоритм sort требует итератора с произвольным доступом. Нельзя.

339. Перечислите типовые виды конструкторов, с помощью которых можно создавать последовательный контейнер.
Конструктор копирования, конструктор заполнения.

340. Можно ли инициализировать контейнер элементами встроенного массива? А элементами другого контейнера? Какими способами это можно сделать?
Да.Да.Шаблонным конструктором.

341. Почему конструктор инициализации, параметрами которого являются итераторы, сделан шаблонным во всех контейнерах?
Чтобы можно было инициализировать вектор из другой последовательности, например, из списка.

342. Какие методы реализованы в контейнере-векторе для доступа к элементам?
Операция индексации, итераторы начала и конца

343. Отличается ли функция at() доступа по индексу от перегруженной операции индексирования и чем?
Да. Проверкой границ доступа.

344. Перечислите методы контейнера deque, относящиеся к определению размеров контейнера.
empty
max_size
size

345. Чем метод size() отличается от метода capacity()? А в чем отличие этих методов от метода max_size()?
сколько хранит, сколько может хранить до изменения размера памяти, сколько вообще может хранить.

346. Перечислите методы контейнера list, предназначенные для вставки удаления и замены элементов. Отличаются ли эти методы от соответствующих методов вектора и дека?
insert
push_front
pop_front
push_back
pop_back
нет, только некоторых методов у вектора нет.

347. Каким образом выполняются операции сравнения контейнеров?
Для сравнения используется оператор <. Строгое слабое упорядочивание элементов. Алгоритмы equal и mismatch.

348. Разрешается ли изменять элемент ассоциативного контейнера, доступный в данный момент по итератору?
Да, но только значение. Тонкий момент: элемент - это пара "ключ-значение", хранение происходит в порядке неубывания ключей.

349. Какие контейнеры называются ассоциативными и почему?
set, multiset, map, multimap. Потому что значение ищется не по порядковому номеру, а по ключу, ассоциируя значение с ключом.

350. Чем контейнер map отличается от контейнера multimap?
Можно хранить уникальные или неуникальные значения.

351. Объясните, почему в ассоциативных контейнерах нельзя изменять элемент, доступный в данный момент по итератору.
Можно безбоязненно изменять значение, но не ключ.

352. По каким причинам в контейнере-множестве не реализованы типовые операции объединения, пересечения, разности и другие?
Это было бы не универсально. Вместо этого реализованы соответствующие алгоритмы на операциях со множествами.
	set_union
	set_intersection
	set_difference
	set_symmetric_difference

353. Как используется структура-пара в ассоциативных контейнерах?
Как единица хранения данных.

354. Объясните, что такое «критерий сортировки», и каким требованиям он должен удовлетворять? Какой критерий сортировки принят по умолчанию?
Это оператор сравнивания. Он должен определить строгое слабое упорядочивание, меньше и равно должны быть транзитивными.

355. Какими преимуществами обладает функция make_pair() по сравнению с конструктором pair()?
Не надо указывать типы, они выводятся, так как это шаблон функции.

356. Почему в контейнерах-отображениях операция индексирования перегружена, а в контейнерах-множествах — нет?
Незачем.

357. Какие гарантии безопасности обеспечивают контейнеры стандартной библиотеки?
Вектор - базовую.
Остальные - не знаю.

358. Что такое «транзакционная гарантия безопасности» и чем она отличается от базовой?
Базовая гарантия - даже при наличии исключений, утечка ресурсов отсутствует.
Транзакционная гарантия - если операция прекращается, то состояние программы остаётся неизменным.
В транзакционной гарантии все ссылки и итераторы будут действительными, в базовой - нет.

359. На какие 4 класса по надежности можно разделить все операции с контейнерами?
---------

360. Что такое «распределитель памяти» и зачем он нужен?
Это абстракция. Любой тип, ведущий себя, как распределитель памяти, является им. Нужен для управления памятью для конкретного типа.
это чистая абстракция. объект класса. ключевые концепции - своя стратегия выделения памяти и избавление разработчика от необходимости иметь дело с сырой памятью.

361. Чем отличается битовый вектор bitset от битового вектора vector<bool>?
Поддерживает операции с битами, длина фиксирована. Проиндексирован. Итератор на vector<bool> не является булевым типом.

362. Дайте определение итератора.
Итератор - это чистая абстракция. Всё, что ведёт себя, как итератор - это и есть итератор. Иными словами, это объект, поддерживающий определённый набор операций.
Ключевые концепции
	Текущий указываемый элемент.
	Операция инкремента.
	Равенство.

363. Что такое «начальный» итератор и «конечный» итератор? Какие методы, связанные с итераторами, обязательно включает каждый контейнер?
Указывает на начало последовательности и на элемент сразу за конечным в последовательности.
begin, end

364. Чем константный итератор отличается от неконстантного?
Нельзя менять значение, доступное по итератору.

365. Объясните, что такое «недействительный» итератор. В каких случаях итераторы становятся недействительными?
Итератор не указывающий на элемент в контейнере или итератор за последним элементом.
В случае изменения размера контейнера.

366. Какие категории итераторов вы знаете? Какие операции обязательно реализуются для всех категорий итераторов?
Чтения, записи, однонаправленный, двунаправленные, произвольного доступа
	Текущий указываемый элемент.
	Операция инкремента.
	Равенство.

367. К какому виду итераторов можно отнести встроенный указатель и почему?
Произвольного доступа. Потому что реализует необходимый набор операций и эти операции выполняются за постоянное время.

368. Какие вспомогательные функции для итераторов вы знаете? В каких случаях оправдано их применение?
advance() distance()
чтобы выразить расстояние между элементами в контейнерах, где произвольный доступ выполняется за линейное время.
Оправдано на небольших контейнерах.

369. Какие адаптеры итераторов реализованы в библиотеке?
revesre iterators.

370. Объясните, почему итераторы реализованы как вложенные классы в контейнерах.
Чтобы определять последовательности, необходимо строго контролировать типы итераторов.

371. Чем отличаются итераторы вставки от обычных итераторов?
Позволяют избежать переполнения контейнеров, изменяя их размеры.

372. Каким образом используются потоковые итераторы?
Это итераторы однонаправленного доступа, которые образуют интерфейс для потока, как контейнера.

373. Какие стандартные функторы реализованы в библиотеке STL? Каково их основное назначение?
логические и арифметические операции
когда имеешь дело с числовыми или логическими классами

374. Для чего нужны адаптеры функторов bind1st() и bind2nd()?
вызывают бинарную функцию в качестве первого и второго аргументов соответственно

375. Как применяются адаптеры-отрицатели?
Возвращают противоположный предикат.

376. Почему алгоритмы remove() не удаляют элементы из контейнеров? Как реально удалить элементы из контейнера?
Потому что тогда изменится размер контейнера и сделает недействительными итераторы. Дорогая операция.
Необходимо явно его сжать и укоротить erase();

377. Чем отличается стабильная сортировка от обычной?
Не меняет местами одинаковые элементы. Гарантированная скорость в худших случаях.

378. Какую функцию выполняет алгоритмы unique()?
Удаляют соседние равные элементы сортированного контейнера.

379. Могут ли стандартные алгоритмы работать со строками?
Да.

380. Нужно ли сортировать ассоциативные контейнеры?
Нет.

381. Можно ли алгоритмы для работы с множествами применять для последовательных контейнеров? При каких условиях?
Можно только для сортированных последовательностей, иначе результат не будет подчиняться правилам работы с последовательностью.

382. Какие алгоритмы предназначены для заполнения контейнера значениями? С какими контейнерами они могут работать?
Модифицирующие
	transform
	fill
	generate
	replace
	reverse

383. Каким образом заполнить с помощью алгоритма generate() последовательный контейнер, не имеющий ни одного элемента?
Использовать inserter

384. Перечислите алгоритмы, предназначенные для операций с каждым элементом контейнера.
for_each
transform
copy
replace
fill

385. Можно ли с помощью алгоритма for_each() изменить элементы контейнера?
Можно через функтор, который передаётся в алгоритм, создать новый контейнер с изменёнными элементами. Но в целом нельзя.

-vtbl, vptr
таблица виртуальных функций. в gcc располагается в начале класса.

-как отрисовать граф наследований.
Необходимо рисовать наследование в порядке объявления в списке наследнование "слева направо", обходить справа налево.

что такое виртуальный базовый класс.
	в тех случаях, когда необходимо предоставить общий базовый класс, необходимо использовать виртуальный базовый класс.

-отрисуйте таблицу области видимости наследования.
	закрытый базовый: только друзья и члены могут использовать открытые и защищённые члены и могут преобразовать D* в B*
	защищённый базовый: то же самое, только добавляются производные классы
	открытый базовый: защищённые члены могут быть использованы членами и друзьями.
	Открытое наследование делает производный класс подтипом базового. Защищённое и закрытое наследование используются для выражения деталей реализации.

-какое наследование по умолчанию в этих случаях
	class XX: B{}
	struct YY: B{}
закрытое
открытое

-какой класс называется "примесью"?
тот, который обеспечивает часть функциональности

-какие типы называются полиморфными
поддерживающие полиморфизм времени выполнения

-когда необходим виртуальный деструктор?
для полиморфных типов, чтобы знать, какой тип уничтожать.

-какие основные функции выполняет стандартная библиотека?
фундамент для других библиотек и поддержка переносимых, довольно нетривиальных типов и операций

-что такое "жирный интерфейс"?
это объединение всех возможных операций интерфейсов производных классов в базовом.

-как реализовать хеширование, как обработать коллизии, привести пример

-в каком порядке инициализируются глобальные переменные? переменные класса?
порядок объявления в пределах единицы трансляции. в порядке объявления.

-как сравниваются строки?
лексикографически

-узнать сложность, асимптотическую О-оценку каждой операции, которой я пользуюсь.
Цель асимптотического анализа состоит в нахождении хорошего приближения к точному решению. Чем больше значение параметра, тем меньше относительная ошибка.

-как достигается параллельность на вашей системе
-----------------

-что такое адаптер и какие они бывают
адаптер позволяет использовать что-либо как аргументы алгоритмов
бывают адаптеры функций-членов, указателей на функцию, связыватель, отрицатель
отрицатель позволяет выразить противоположный предикат
связыватель позволяет использовать функтор с двумя аргументами, как функтор с одним, путём связывания одного аргумента со значением.

-что такое спецификация шаблонов: полная и частичная
Описание отличного от стандартного поведения при заданных частных случаях инстанцирования шаблона.

-что такое выведение типов
Процесс, при котором компилятор инстанцирует шаблон функции типом аргумента в её вызове.

-может ли выведение применяться к конструкторам
Нет.

-что такое куча и как её организовать
способ организации последовательности, когда первым является элемент с наибольшим значением.

-Как выглядит инициализатор для структуры?
Так же, как и для массива (и класс им можно инициализировать)

-какие виды шаблонов могуть быть аргументами других шаблонов?
только шаблоны классов

-что такое часовой и где он применяется
Это класс, который выполняет префиксный и инфиксный код в своём конструкторе и деструкторе. В стандартной библиотеке применяется в реализации ввода-вывода, когда надо подготовить поток. Вообще применение таково: в начале области видимости конструируется, в конце области видимости уничтожается. Например, можно реализовать блокировку.

void foobar( void );
void foobar();
есть ли разница?
Есть, если заголовки расшарены между С и С++.
В С первая строка означает "функция не берёт аргументов", а вторая "функция берёт некоторое количество некоторых аргументов". В С++ обе строки означают, что ф-я не берёт аргументов.

что такое безопасность исключений и какая она бывает?
------------