1. Что определяет класс? Чем обличается класс от объекта? 
Класс определяет тип (объектов). Объект - экземпляр класса (в памяти).
2. Можно ли объявлять массив объектов? А массив классов? 
Да. Нет (В метарограммировании - можно: boost::tuple, boost::mpl::vector, ...).
3. Разрешается ли объявлять указатель на объект? А указатель на класс? 
Да. Нет.
4. Допускается ли передавать объекты в качестве параметров, и какими способами? А возвращать как результат? 
Да: по значению, по указателю, по ссылке. Да, теми же способами (нельзя(т.к. UB) возвращать указатель или ссылку на локальный объект).
5. Как называется использование объекта одного класса в качестве поля другого класса? 
Композиция. (или все-же Агрегирование?)
6. Является ли структура классом? Чем класс отличается от структуры? 
Да. У классов по умолчанию private поля и private наследование, у структур - public.
7. Какие ключевые слова в С++ обозначают класс? 
class, struct.
8. Объясните принцип инкапсуляции. 
Объединение данных и методов для работы с ними. А также возмможность прятать функции и члены от внешнего использования.
9. Что такое композиция? 
Тип отношения между объектами, когда один является частью другого (его членом).
10. Для чего используются ключевые слова public и private? 
Для определения "доступности" определенных частей класса извне. 
При наследовании class A : public B - A is B; class A : private B - A can use public members of B
11. Можно ли использовать ключевые слова public и private в структуре? 
Да.
12. Существуют ли ограничения на использование public и private в классе? А в структуре? 
Нет.
13. Обязательно ли делать поля класса приватными? 
Нет.
14. Что такое метод? Как вызывается метод? 
Функция-член класса. a.f() или a->f() или через указатель на функцию член класса: (a.*pf)() или (a->*pf)(). 
Статический метод обычно вызывают так: A::f()
15. Может ли метод быть приватный? 
Да.
16. Как определить метод непосредственно внутри класса? А вне класса? Чем эти определения отличаются? 
class A { void f() {} }; // <=> class A { inline void f() {} }; 
class A { void f(); }; void A::f() {}
17. Можно в методах присваивать параметрам значения по умолчанию? 
Да.
18. Что обозначается ключевым словом this? 
В нестатических методах - указатель на объект у которого этот метод вызван. 
Тип this: A*, const A* - для const методов, volatile A* - для volatile методов, const volatile A* - для cv-методов
19. Зачем нужны константные методы? Чем отличается определение константного метода от обычного? 
Чтобы гарантировать вызывающей стороне что состояние объекта не будет изменено. 
struct A { void cf() const {} };
20. Может ли константный метод вызываться для объектов-переменных? А обычный метод — для объектов-констант? 
Да. Нет.
21. Объясните принцип полиморфизма. 
Возможность программного кода работать с объектами разных классов одинаковым образом. 
Различается статический (на этапе компиляции - шаблоны, перегрузка функций и операторов) 
и динамический (на этапе выполнения - виртуальные функции) полиморфизм.
22. Сколько места в памяти занимает объект класса? Как это узнать? 
sizeof(Class)
23. Каков размер «пустого» объекта? 
Complete objects and member subobjects of class type shall have nonzero size. Base class subobjects are not so constrained.
24. Влияют ли методы на размер объекта? 
Нет. Если есть виртуальные функции, то размер объекта уведичивается засчет указателя на таблицу виртуальных функций.
25. Одинаков ли размер класса и аналогичной структуры? 
Да.
26. Какие операции нельзя перегружать? Как вы думаете, почему? 
. .* :: ?: sizeof() typeid()
27. Можно ли перегружать операции для встроенных типов данных? 
28. Можно ли при перегрузке изменить приоритет операции? 
29. Можно ли определить новую операцию? 
Нет. Нет. Нет.
30. Перечислите особенности перегрузки операций как методов класса. Чем отличается перегрузка внешним образом от перегрузки как метода класса? 
При перегрузке операторов как методов класса: 
1. Первый параметр оператора опускается (если это бинарный оператор, то прописывается один параметр, если унарный - ничего), этим первым параметром становится экземпляр класса (this). 
2. Их можно сделать константными методами. 
3. Также при такой перезгрузке имеется доступ к не-public областям. 
А иначе (при внешней перезгрузке): 
1.. Если перезгрузка веншняя, то одним из параметров долна быть пользовательский тип данных (потому как нельзя перегружать операторы для всроенных типов). 
2. Такой оператор не может быть константным. 
3. Он не имеет доступ к не-public областям, только если он не был обьявлен другом (friend).
31. Какой результат должны возвращать операции с присваиванием? 
ссылку на объект класса. ( A& operator= ( const A& rhs ) { A(rhs).swap(*this); return *this; } )
32. Как различаются перегруженная префиксная и постфиксная операции инкремента и декремента? 
Постфиксная - с параметром типа int, префиксная - без параметров. 
  A & operator++ () { ..increment.. return *this; }  // prefix 
  A operator++ (int) { A tmp(*this); ++*this; return tmp; }  // postfix
33. Что означает выражение *this? В каких случаях оно используется? 
см 18, 31, 32.
34. Какие операции не рекомендуется перегружать как методы класса? Почему? 
operator, 
??? - даже не знаю что еще :(.
35. Какие операции разрешается перегружать только как методы класса? 
operator=, operator->, operator(), operator[], приведение типа. 
operator-> обязан иметь в качестве возвращаемого значения struct, class, union или ссылку на это
36. Дайте определение дружественной функции. Как объявляется дружественная функция? А как определяется? 
Дружественная функция имеет доступ к private (и protected) членам класса. 
class A { int m; friend void f(); }; void f() { ... }
37. Дайте определение конструктора. Каково назначение конструктора? Перечислите отличия конструктора от метода. 
Инициализация класса. Не имеет возвращаемого значения, не может быть статическим, виртуальным, cv, 
в конструкторе не работает механизм виртуальных функций (т.к. еще не инициализирована таблица виртуальных функций).
38. Сколько конструкторов может быть в классе? Допускается ли перегрузка конструкторов? Какие виды конструкторов создаются по умолчанию? 
От 0 до +inf. Да. Конструктор по умолчанию и конструктор копирования (default ctor and copy ctor).
39. Может ли конструктор быть приватным? Какие последствия влечет за собой объявление конструктора приватным? 
Да. Невозможность создавать экземпляры класса извне (т.е. можно создавать только через статические функции и друзей).
40. Приведите несколько случаев, когда конструктор вызывается неявно. 
Передача в качестве параметра по значению. 
Передача в качестве параметра с приведением типа (const ref arg). 
Возврат из функции по значению.

41. Как проинициализировать динамическую переменную? 
A * a = new A(...);
Либо placement new: 
A * a = new(ptr_on_block_in_mem) (arguments to constructor);
42. Как объявить константу в классе? Можно ли объявить дробную константу?
Вторая часть вопроса - Да.
struct A { const int a; A() : a(10) {} }; 
struct A { static const int a = 10; }; // only const static integral data members can be initialized inside a class or struct 
struct A { static const int a; }; A::a = 10; 
struct A { static const double a; }; A::a = 10.;
43. Каким образом разрешается инициализировать константные поля в классе? 
В списке инициализации. Для static - см 42. При этом, в каждом конструкторе. Замечание: умалчиваемые конструкторы 
перестают быть доступны. То же касаетя ссылок как полей.
44. В каком порядке инициализируются поля в классе? Совпадает ли этот порядок с порядком перечисления инициализаторов в списке инициализации конструктора? 
В порядке их объявления. Нет.
45. Какие конструкции С++ разрешается использовать в списке инициализации качестве инициализирующих выражений? 
??? Отмечаем порядок. Такое недопустимо: 
class A
{
  int* a;
  int* b;
  A(): b(new int()), a(b)
  {
  }
};
При выполнении конструктора-деструктора вызовы виртуальных функции не 
виртуальны. 
46. Какой вид конструктора фактически является конструктором преобразования типов? 
не explicit конструктор с одним аргументом (конструктор инициализации).
47. Для чего нужны функции преобразования? Как объявить такую функцию в классе? 
Вроде бы это всегда называлось не "функция преобразования", а "оператор приведения типа". 
Преобразовывать тип к другому. struct A { operator C () {...}; operator B () const {...}; };
48. Как запретить неявное преобразование типа, выполняемое конструктором инициализации? 
Перед соответствующим конструктором написать explicit: struct A { explicit A(int) {} };
49. Какие проблемы могут возникнуть при определении функций преобразования? 
??? (видимо нежелательные/сложнопредсказуемые/неожиданные приведения типов)
50. Для чего служит ключевое слово explicit? 
см 48.
51. Влияет ли наличие целочисленных констант-полей на размер класса? 
Да. (ессно если не static)
52. Разрешается ли объявлять массив в качестве поля класса. Как присвоить элементам массива начальные значения? 
Да. 
int a[2] = {1, 2}; В классе - никак (за исключением 55).
53. Сколько операндов имеет операция индексирования []? Какой вид результата должна возвращать эта операция? 
Один. Любой.
54. Для чего нужны статические поля в классе? Как они определяются? 
Статические поля - переменные класса (нестатические поля - переменные объекта). 
Определяются - вне класса (за исключением 42 (initialized const static integral data members)): 
struct A { static int a; }; int A::a;
55. Как объявить в классе и проинициализировать статический константный массив? 
struct A { static const int a[2]; }; const int A::a[2] = {1, 2};
56. Что такое выравнивание и от чего оно зависит? Влияет ли выравнивание на размер класса? 
Implementation defined. Да.
57. Дайте определение контейнера. 
Containers are objects that store other objects. (см стандарт 2003: стр 465)
58. Какие виды встроенных контейнеров в С++ вы знаете? 
Sequences              : vector, list, deque, queue, stack 
Associative containers  : map, set, multimap, multiset 
Other                  : priority_queue, bitset
59. Какие виды доступа к элементам контейнера вам известны? 
Разыменование итератора, оператор индексирования.
60. Чем отличается прямой доступ от ассоциативного? 
???
61. Перечислите операции, которые обычно реализуются для последовательного доступа к элементам контейнера. 
begin, end, инкремент итератора
62. Дайте определение итератора. 
TODO: from GD
63. Можно ли реализовать последовательный доступ без итератора? В чем преимущества реализации последовательного доступа с помощью итератора? 
Да. Единообразная работа с различными сущностями.
64. Что играет роль итератора для массивов С++? 
Указатель.
65. Что такое деструктор? Может ли деструктор иметь параметры? 
Нет.
66. Почему для классов-контейнеров деструктор надо писать явным образом? 
да вроде незачем :) или я чего-то не знаю :( 
У стандартных классов-контейнеров в стандарте прописано, что должен быть деструктор.
67. Допускается ли перегрузка деструкторов? 
Нет.
68. Что такое «глубокое копирование» и когда в нем возникает необходимость? 
Когда при копировании указателя нужно скопировать объект на который он указывает.
69. Какое копирование осуществляет стандартный конструктор копирования? 
Вызывает конструкторы копирования баз и членов.
70. Чем отличается копирование от присваивания? 
Это разные операции :) 
Копирование - создание одного объекта по другому (с помощью конструктора копирования). 
Присваивание - изменение содержимого существующего объекта (присваиванием в него содержимого другого объекта).
71. Объясните, почему в операции присваивания требуется проверка присваивания самому себе? 
Необязательно, например каноническая реализация через swap и конструктор копирования этой проверки не осуществляет (см. 31).
72. Можно ли в качестве операции индексирования использовать операцию вызова функции ()? В чем ее преимущества перед операцией []? 
Можно, ей можно передавать нескольео аргументов.
73. Почему необходимо писать два определения операции индексирования? Чем они отличаются? 
Отличаются наличием const, обычно нужны для того, чтобы была возможность изменять содержимое не const контейнера, 
и при этом иметь доступ к элементам const контейнера: 
struct A 
{ 
  T& operator[] (int); 
  const T& operator[] (int) const; 
};
74. Дайте определение вложенного класса. 
struct A { struct NestedClass {}; };
75. Можно ли класс-итератор реализовать как внешний класс? А как вложенный? В чем отличия этих методов реализации? 
Да. Да. ???.
76. Может ли объемлющий класс иметь неограниченный доступ к элементам вложенного класса? А вложенный класс — к элементам объемлющего? 
Да (если я правильно понял вопрос :) ).
77. Ограничена ли глубина вложенности классов? 
Нет.
78. Можно ли определить вложенный класс внешним образом? Зачем это может понадобиться? 
struct A { struct NestedClass; }; struct A::NestedClass {}; 
Если NestedClass нуждается в определении класса в который он вложен.
79. Каким образом вложенный класс может использовать методы объемлющего класса? А объемлющий — методы вложенного? 
Каким угодно. (???)
80. Что такое «запредельный» элемент, какую роль он играет в контейнерах? 
end() - Элемент следующий за последним. Используется в условии окончании перебора элементов (и соответственно возвращается при неудачном поиске в контейнере и аналогичных ситуациях).
81. Объясните, по каким причинам трудно написать универсальный контейнер, элементы которого могут иметь произвольный тип. 
Из-за строгой типизации (нужен либо VARIANT, либо dynamic_cast).
82. Назовите ключевые слова С++, которые используются для обработки исключений. 
try, catch, throw
83. Исключение — это: 
1) событие; 
2) ситуация; 
3) объект; 
4) ошибка в программе; 
5) прерывание;
3)
84. Каким образом исключение генерируется? 
Происходит раскрутка стека
85. Каковы функции контролируемого блока? 
Отловить исключения которые сгенериованы внутри него.
86. Что обозначается ключевым словом catch? 
1) контролируемый блок;        (try-cath) 
2) блок обработки исключения;  (catch) 
3) секция-ловушка;              (try) 
4) генератор исключения;        (throw) 
5) обработчик прерывания;      (???)
2)
87. Какого типа может быть исключение? 
Любого.
88. Сколько параметров разрешается писать в заголовке секции-ловушки? 
Один.
89. Какими способами разрешается передавать исключение в блок обработки? 
По значению, по ссылке или по указателю.
90. Объясните, каким образом преодолеть ограничение на передачу единственного параметра в блок обработки. 
Использовать несколько блоков обработки.
91. Почему нельзя выполнять преобразования типов исключений при передаче в секцию-ловушку? 
Можно исполнять dynamic_cast downcasting. 
Если имелось в виду то что не работают операторы преобразования, то потому что catch-блок хранит информацию о конкретнных типах. 
TODO: написать подробней и понятней
92. Напишите конструкцию, которая позволяет перехватить любое исключение. 
catch(...) {}
93. Могут ли контролируемые блоки быть вложенными? 
Да.
94. Зачем нужен «контролируемый блок-функция» и чем он отличается от обычного контролируемого блока? 
Нужен для перехвата исключения в списке инициализации конструктора. Обычно используется для преобразования типа исключения (ловится исключение однго типа и кидается другого). 
catch-блок конструктора не может использовать return; catch-блок конструктора обязан завершиться генерацией исключения и если это не происходит явно, то при выходе из catch-блока происходит вызов "throw;" 
Пример: 
class A : B {C c;}; 
A::A() 
try : B(...), c(...) 
{ 
... 
} catch (...) { ... } 
{ /*ctor body*/ }
95. Перечислите возможные способы выхода из блока обработки. 
Нормальный выход. Генерация другого исключения. Повторная генерация исключения: throw;.
96. Каким образом исключение «передать дальше»? 
throw;
97. Сколько секций-ловушек должно быть задано в контролируемом блоке? 
1 .. +inf
98. Что такое «спецификация исключений»? 
Указание списка исключений, которые может генерировать функция: 
void f() throw ( const char *, std::logic_error ); // функция может генерировать исключения типа const char *, std::logic_error 
void f() throw (); // функция не генерирует никакие исключения
99. Что происходит, если функция нарушает спецификацию исключений? 
Вызов обработчика unexpected
100. Учитывается ли спецификация исключений при перегрузке функций? 
Спецификация исключений потомка должна не менее "строгой", 
за исключением того что потомок может генерировать исключения производные от исключений предка. 
(Т.е. в соответствии с принципом LSP)
101. Что такое «иерархия исключений»? 
иерархия исключений она и есть иерархия исключений :)
102. Существуют ли стандартные исключения? Назовите два-три типа стандартных исключений. 
exception <- logic_error <- domain_error 
                        <- invalid_argument 
                        <- length_error 
                        <- out_of_range 
        <- runtime_error <- range_error 
                        <- overflow_error 
                        <- underflow_error
103. Поясните «взаимоотношение» исключений и деструкторов. 
При генерации исключения из-за раскрутки стека вызываются деструкторы локальных объектов. 
Если в этот момент сгенерируется новое исключение это приведет к вызову terminate()
104. Объясните, зачем может понадобиться подмена стандартных функций завершения. 
Для собственной обработки подобных ситуаций (обычно для их протоколирования).
105. Какие виды нестандартных исключений вы знаете? 
bad_typeid, bad_typecast
106. В чем отличие механизма структурной обработки исключений Windows от стандартного механизма? 
???
базовому 
public - is a (наследование интерфейса) 
private, protected - наследование реализации
111. Какие функции не наследуются? 
Конструкторы и operator=
112. Сформулируйте правила написания конструкторов в производном классе. 
???
113. Каков порядок вызова конструкторов? А деструкторов? 
Порядок конструирования объекта: 
базовые виртуальные классы 
таблица виртуальных классов 
базовые классы 
таблица виртуальных функций 
члены ("поля") 
сам класс
Деструктор - в обратном порядке.
114. Можно ли в производном классе объявлять новые поля? А методы? 
Да. Да.
115. Если имя нового поля совпадает с именем унаследованного, то каким образом разрешить конфликт имен? 
Пользовать BASE::Name
116. Что происходит, если имя метода-наследника совпадает с именем базового метода? 
Происходит перекрытие имен. Решение - 115. 
Подстава в том что перекрывается не только совпадающие функции, а вообще все с таким именем.
117. Сформулируйте принцип подстановки. 
LSP: Subtypes must be substitutable for their base types.
118. Когда выполняется понижающее приведение типов? 
Когда у программы плохой дизайн :))
119. Объясните, что такое «срезка» или «расщепление». 
Это когда какой-нибудь идиот передает объект в функцию, принимающую базовый класс по значению, класс наследник.
120. Объясните, зачем нужны виртуальные функции. 
Для реализации динамического полиморфизма.
121. Что такое связывание? 
Определение того какая функция должна быть вызвана.
122. Чем «раннее» связывание отличается от «позднего»? 
Раннее - на этапе компиляции (разрешение перегрузки), позднее - на этапе выполнения (виртуальные функции).
123. Какие два вида полиморфизма реализованы в С++? 
Статический и динамический.
124. Дайте определение полиморфного класса. 
Класс с виртуальными функциями.
125. Может ли виртуальная функция быть дружественной функцией класса? 
Да.
126. Наследуются ли виртуальные функции? 
Да.
127. Каковы особенности вызова виртуальных функций в конструкторах и деструкторах? 
Механизм виртуальных функций не работает.
128. Можно ли сделать виртуальной перегруженную операцию, например, сложение? 
Да.
129. Может ли конструктор быть виртуальным? А деструктор? 
Нет. Да.
130. Как виртуальные функции влияют на размер класса? 
Указателем на таблицу виртуальных функций.
131. Как объявляется «чистая» виртуальная функция? 
struct A { virtual voif f() = 0; };
132. Дайте определение абстрактного класса. 
Класс содержащий хотя бы одну чисто виртуальную функцию.
133. Наследуются ли чистые виртуальные функции? 
Да. (иначе зачем они нужны :) )
134. Можно ли объявить деструктор чисто виртуальным? 
Да.
135. Чем отличается чистый виртуальный деструктор от чистой виртуальной функции? 
Он обязан иметь определение. (т.к. будет вызван)
136. Зачем требуется определение чистого виртуального деструктора? 
Чтобы сделать класс абстрактным. 
Наверное правильно было бы ответить и на вопрос: 
136.(1) Зачем требуется определение виртуального деструктора? 
Чтобы корректно удалять объекты по указателю на базовый класс.
137. Наследуется ли определение чистой виртуальной функции? 
Нет.
138. Приведите классификацию целей наследования. 
Наследование интерфейса и наследование реализации
139. Объясните разницу наследования интерфейса от наследования реализации.
140. Назовите причины, требующие разделения программ на части. 
Удобней использовать.
141. Дайте определение термина «единица трансляции»? 
(Transalation unit) 
Исходный файл (cpp, cxx, C, ...) c подключенными заголовочными файлами 
и другими файлами подключенными с помощью include.
142. Чем отличается файл с исходным текстом от единицы трансляции? 
Файл с исходным текстом не обязательно является единицей трансляции.
143. Существуют ли в С++ конструкции, позволяющие идентифицировать отдельный модуль? 
??? (подразумевается namespace?)
144. Какие способы сборки программы вы можете назвать? 
Полная, частичная.
145. Что такое «объектный модуль»? Программа, которая «собирает» объектные модули в программу, называется _____________ ? 
.obj. Линковщик (linker).
146. В чем заключается отличие аргумента «файл» от <файл> в директиве #include? 
Локальные и глобальные инклуды (т.е. логическое разделение). 
Отличается тем где компилятор пытается найти подключаемый файл в первую очередь.
147. Что такое ODR? 
One Definition Rule (Правило Одного Определения).
148. Объясните, что такое «страж» включения и зачем он нужен. 
В .h файлах, для того чтобы избежать повторного подключения пишут: 
<blah_blah_blah.h>: 
#ifndef BLAH_BLAH_BLAH__ 
#define BLAH_BLAH_BLAH__ 
... 
#endif // BLAH_BLAH_BLAH__
149. Является ли интерфейс класса его определением? 
Да.
150. Сколько определений класса может быть в единице трансляции? 
Одно.
151. Сколько определений класса может быть в многофайловой программе? 
Много.
152. Чем отличаются стандартные заголовки <string>, <string.h> и <cstring>? 
STL. CRT. CRT.
153. Объясните суть идиомы Pimpl. 
В классе хранится указатель на реализацию, реализация которого скрыта от пользователя (есть только forward definition). 
Методы класса реализованы посредством класса реализации.
154. Что такое делегирование и как его можно использовать для повышения степени инкапсуляции?

155. Каким образом глобальную переменную, определенную в одной единице трансляции, сделать доступной в другой единице трансляции? А константу? 
extern
156. Можно ли использовать слово extern при объявлении функций? 
можно
157. Как локализовать объявление функции в файле? 
использовать static или неименованные пространства имен
158. Чем отличается «внешнее» связывание от «внутреннего» связывания? 
возможностью доступноступа извне
159. Что такое «спецификации компоновки»?

160. Какие объекты обладают внутренним связыванием по умолчанию?

161. Какие области видимости имен вы знаете? 
Глобальные и нет.
162. Для чего используются пространства имен? 
Для удобства (логическое выделение части функциональности). Для избежания конфликтов имен.
163. Чем отличаются именованные и неименованные пространства имен?

164. Могут ли пространства имен быть вложенными? 
Да.
165. Для чего применяются алиасы пространства имен? 
Для удобства. Для избежания конфликтов имен.
166. Как сделать члены пространства имен доступными в нескольких (в пределе — во всех) файлах программного проекта? 
uses namespace a; // ???
167. Объясните разницу между статической и динамической инициализацией. 
Инициализация статических переменных происходит до вызова main. 
Инициализация статических переменных определенных внутри функции происходит не позже их первого использования.
168. В чем состоит проблема инициализации глобальных статических переменных? 
В том, что порядок инициализации не известен.
169. Какие элементы класса можно объявлять статическими? 
Методы, функции-члены, операторы. (за искл 175)
170. Можно ли объявить в классе статическую константу? А константный статический массив? 
Да. Да. (см. 42, 52)
171. А какие статические поля можно инициализировать непосредственно в классе? 
only const static integral data members
172. Как определяются статические поля? В какой момент работы программы выполняется инициализация статических полей? 
struct A { static int sa; }; 
До вызова main (см. 167)
173. Сколько места в классе занимают статические поля ? 
0
174. Чем отличается статический метод от обычного? 
Нету this
175. Какие методы класса не могут быть статическими? 
Операторы, которые должны быть non-static (см. 35), конструкторы и деструкторы, виртуальные функции.
176. Какие применения статических полей вы можете привести? А каким образом применяются статические методы? 
Пример: контроль создания объектов класса: private ctor, static счетчик объектов, статик функция, создающая объекты.
177. Приведите структуру и принцип действия паттерна Singleton. 
Есть разные реализации синглетона (общая проблема - время жизни). 
template < class T > struct SingletonT : public T { static T & inst() { T t; return t; } private: /*ctor, copy ctor, assignment*/ };
178. Для чего предназначены шаблоны? 
Изначально - для того чтобы не писать одинаковый код для разных типов. 
Потом появилось еще и метарограммирование с использованием шаблонов.
179. Какие виды шаблонов в С++ вы знаете? 
Шаблоны классов и шаблоны функций.
180. Объясните термин «инстанцирование шаблона». 
Подстановка реальных типов в качестве аргументов шаблона.
181. В чем разница между определением и объявлением шаблона? 
template < class T > struct TA; // declaration 
template < class T > struct TA { T a; }; // definiftion
182. Объясните назначение ключевого слова typename. 
В списке параметров шаблона может использоваться как синоним "class" 
Внутри шаблона используется для указания компилятору вложенного типа типа зависящего от параметра шаблона: 
template < class T > struct TA { typedef typename T::iterator type; }; // без typename - ошибка компиляции
183. Какие виды параметров разрешается задавать в шаблоне класса? А в шаблоне функции? 
...
184. Можно ли параметрам шаблона присваивать значения по умолчанию? 
Да.
185. Может ли параметром шаблона быть другой шаблон? Каковы особенности объявления параметра-шаблона? 
Да: template < template <class> class TT > TA { TT<int> m; };
186. Что такое специализация шаблона? Объясните разницу между полной и частичной специализацией. 
Это частный случай некоторого шаблона при фиксированной части аргументов. Полная специализация - все аргументы фиксированы. 
Пример: 
template < class T, class U > struct TA {}; // Primary template 
template < class T > struct TA<T, int> {}; // Partial specialization 
template <> struct TA<int, int> {}; // Explicit specialization
187. Разрешается ли специализировать шаблон функции? 
Разрешается только полная специализация, т.к. частичная - суть перегрузка.
188. Может ли класс-шаблон быть вложенным в другой класс-шаблон? А в обычный класс? 
Да. Да.
189. Можно ли объявить в классе шаблонный метод? А шаблонный конструктор? 
Да. Да.
190. Можно ли перегружать функцию-шаблон? 
Да.
191. Какие параметры функции-шаблона выводятся автоматически? 
Не dependent types.
192. Может ли шаблон класса быть наследником обычного класса? А обычный класс от шаблона? 
Да. ???.
193. Объясните, что такое класс свойств (класс трактовок). 
traits - вспомогательный шаблонный класс который содержит вложенные типы и статические функции соответсвующие данному типу (предназначенные для работы с ним).
194. Каким образом можно использовать возможность наследования обычного класса от шаблона? 
???
195. Может ли шаблонный конструктор быть конструктором по умолчанию? 
Нет.
196. Для чего применяются директивы явного инстанцирования? 
Дл того чтобы соответствующая инстанциация была скомпилирована/слинкована.
197. Объясните, в чем состоят проблемы, возникающие при разделении шаблонного класса на интерфейс и реализацию? 
Реализация не может быть вынесена в .cpp файл. (т.к. экспорт шаблонов не поддерживается большей частью компиляторов)
198. Что такое «модель явного инстанцирования» и как она работает? 
Реализация вынесена в .cpp файл и есть явно инстанциация для нужных типов.
199. Может ли шаблонный класс иметь «друзей»? 
Да.
200. Какие проблемы возникают при объявлении дружественной функции для класса-шаблона?
201. Разрешается ли определять в классе-шаблоне статические поля? А статические методы? 
Да. Да.
202. Что такое «инициализация нулем»? 
(zero-initialization) объект инициализируется значением 0 (преобразованное в тип объекта). 
Инициализация по умолчанию POD типов производит инициализацию нулями. 
Для стсатических переменных встроенных типов производиться инициализация нулямию

